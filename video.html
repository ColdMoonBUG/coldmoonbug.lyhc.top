<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>短视频滚动播放</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        .video-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        video {
            width: 100%;
            max-height: 100vh;
            margin-bottom: 20px;
            background: black;
        }
    </style>
</head>
<body>
    <div class="video-container" id="videoContainer"></div>

    <script>
        let videoContainer = document.getElementById('videoContainer');
        let currentVideoIndex = 0;
        const maxPreload = 5; // 预加载视频数量
        const maxVideosOnScreen = 10; // 屏幕上最多显示视频数量
        let loading = false; // 避免无限加载标志位

        // 用于记录加载过的视频链接
        let videoHistory = [];

        // 初次加载第一个视频并预加载后续视频
        loadNextVideo();
        preloadVideos(maxPreload - 1);

        // 监听滚动事件，检测是否接近页面底部或顶部
        window.addEventListener('scroll', debounce(() => {
            if (!loading && window.innerHeight + window.scrollY >= document.body.offsetHeight - 50) {
                // 用户接近页面底部，加载下一个视频
                loadNextVideo();
                preloadVideos(1); // 继续预加载下一个视频
            } else if (window.scrollY <= 50 && currentVideoIndex > 0) {
                // 用户接近页面顶部，显示上一个视频
                loadPreviousVideo();
            }
        }, 100));

        // 键盘监听，s键和下箭头键加载下一个视频
        window.addEventListener('keydown', (e) => {
            if (e.key === 's' || e.key === 'ArrowDown') {
                loadNextVideo();
            }
        });

        // 加载下一个视频并显示
        async function loadNextVideo() {
            if (loading) return; // 避免重复加载
            loading = true;
            try {
                if (currentVideoIndex < videoHistory.length) {
                    // 从预加载的视频池中获取下一个视频
                    showVideo(videoHistory[currentVideoIndex]);
                    currentVideoIndex++;
                } else {
                    // 从接口获取新的视频并显示
                    const response = await fetch('https://v2.api-m.com/api/meinv');
                    const result = await response.json();
                    const videoUrl = result.data;

                    videoHistory.push(videoUrl);
                    showVideo(videoUrl);
                    currentVideoIndex++;
                }

                // 控制内存：超过一定数量的视频时移除最早的视频
                if (videoContainer.children.length > maxVideosOnScreen) {
                    let firstVideo = videoContainer.firstElementChild;
                    if (firstVideo) {
                        firstVideo.pause(); // 暂停第一个视频
                        videoContainer.removeChild(firstVideo);
                    }
                }
            } catch (error) {
                console.error('获取视频失败:', error);
            }
            loading = false; // 重置标志位
        }

        // 预加载指定数量的视频
        async function preloadVideos(count) {
            for (let i = 0; i < count; i++) {
                const response = await fetch('https://v2.api-m.com/api/meinv');
                const result = await response.json();
                const videoUrl = result.data;

                videoHistory.push(videoUrl);
            }
        }

        // 显示视频
        function showVideo(videoUrl) {
            // 暂停所有其他视频
            const videos = videoContainer.querySelectorAll('video');
            videos.forEach(video => {
                video.pause();
            });

            // 创建并添加新视频
            let videoElement = document.createElement('video');
            videoElement.src = videoUrl;
            videoElement.controls = true;
            videoElement.autoplay = true;
            videoElement.muted = true;
            videoElement.loop = true;

            videoContainer.appendChild(videoElement);
        }

        // 返回上一个视频
        function loadPreviousVideo() {
            if (currentVideoIndex > 1) {
                currentVideoIndex--;
                let previousVideo = videoContainer.children[currentVideoIndex - 1];
                if (previousVideo) {
                    // 不自动滚动
                }
            }
        }

        // 防抖函数，避免滚动事件频繁触发
        function debounce(func, delay) {
            let debounceTimer;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(context, args), delay);
            };
        }
    </script>
</body>
</html>
